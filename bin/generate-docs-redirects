#!/usr/bin/env python3.12
"""
www.querypie.com/docs/* 리다이렉트 맵 생성기

docs.querypie.com과 aip-docs.app.querypie.com의 sitemap.xml에서
URL 목록을 가져와, www.querypie.com/docs/* 요청에 대한 리다이렉트 규칙을 생성합니다.

규칙:
  - sitemap에 존재하는 URL → 301 (영구 리다이렉트)
  - sitemap에 존재하지 않는 URL → docs.querypie.com으로 307 (임시 리다이렉트)

사용법:
  generate-docs-redirects                    # JSON 출력
  generate-docs-redirects --format nginx     # nginx 설정 출력
  generate-docs-redirects --format nextjs    # next.config.js redirects 출력
  generate-docs-redirects --format vercel    # vercel.json redirects 출력
"""

import argparse
import json
import sys
import urllib.request
import xml.etree.ElementTree as ET
from pathlib import Path
from urllib.parse import urlparse

SITEMAP_NS = {'sm': 'http://www.sitemaps.org/schemas/sitemap/0.9'}

TARGETS = [
    {
        'name': 'aip-docs.app.querypie.com',
        'base_url': 'https://aip-docs.app.querypie.com',
    },
    {
        'name': 'docs.querypie.com',
        'base_url': 'https://docs.querypie.com',
    },
]

FALLBACK_HOST = 'https://docs.querypie.com'


def fetch_sitemap_urls(base_url: str) -> list[str]:
    """sitemap.xml에서 모든 URL을 가져옵니다 (sitemap index 지원)."""
    urls = []
    sitemap_url = f'{base_url}/sitemap.xml'
    req = urllib.request.Request(sitemap_url, headers={'User-Agent': 'Mozilla/5.0'})
    with urllib.request.urlopen(req, timeout=30) as resp:
        root = ET.fromstring(resp.read())

    # sitemap index인 경우 하위 sitemap을 순회
    sitemaps = root.findall('sm:sitemap/sm:loc', SITEMAP_NS)
    if sitemaps:
        for sm_loc in sitemaps:
            child_url = sm_loc.text.strip()
            req2 = urllib.request.Request(child_url, headers={'User-Agent': 'Mozilla/5.0'})
            with urllib.request.urlopen(req2, timeout=30) as resp2:
                child_root = ET.fromstring(resp2.read())
            for loc in child_root.findall('sm:url/sm:loc', SITEMAP_NS):
                urls.append(loc.text.strip())
    else:
        for loc in root.findall('sm:url/sm:loc', SITEMAP_NS):
            urls.append(loc.text.strip())

    return urls


def build_redirect_map(targets: list[dict]) -> dict:
    """대상 사이트들의 sitemap을 가져와 path → redirect 정보 맵을 생성합니다."""
    # path → {'target': url, 'status': 301}
    redirect_map = {}

    for target in targets:
        name = target['name']
        base_url = target['base_url']
        print(f'Fetching sitemap: {name}...', file=sys.stderr)

        try:
            urls = fetch_sitemap_urls(base_url)
            print(f'  {len(urls)} URLs', file=sys.stderr)
        except Exception as e:
            print(f'  오류: {e}', file=sys.stderr)
            continue

        for url in urls:
            parsed = urlparse(url)
            path = parsed.path.rstrip('/')
            if not path:
                path = '/'
            # /docs prefix를 붙여서 www.querypie.com 기준 경로 생성
            source_path = f'/docs{path}'
            if source_path not in redirect_map:
                redirect_map[source_path] = {
                    'target': url,
                    'status': 301,
                    'source': name,
                }

    return redirect_map


def output_json(redirect_map: dict, fallback_host: str):
    """JSON 형식으로 출력합니다."""
    result = {
        'description': 'www.querypie.com/docs/* redirect map',
        'fallback': {
            'host': fallback_host,
            'status': 307,
            'note': 'sitemap에 없는 URL은 docs.querypie.com으로 307 redirect',
        },
        'rules': [],
    }
    for source, info in sorted(redirect_map.items()):
        result['rules'].append({
            'source': source,
            'destination': info['target'],
            'statusCode': info['status'],
        })
    result['stats'] = {
        'total_rules': len(result['rules']),
        'by_target': {},
    }
    for info in redirect_map.values():
        src = info['source']
        result['stats']['by_target'][src] = result['stats']['by_target'].get(src, 0) + 1

    print(json.dumps(result, ensure_ascii=False, indent=2))


def output_nginx(redirect_map: dict, fallback_host: str):
    """nginx 설정 형식으로 출력합니다."""
    print('# www.querypie.com/docs/* redirect rules')
    print('# Generated by generate-docs-redirects')
    print()
    print('map $uri $docs_redirect_target {')
    print('    default "";')
    for source, info in sorted(redirect_map.items()):
        print(f'    {source} {info["target"]};')
    print('}')
    print()
    print('# nginx server block에 추가:')
    print('location /docs/ {')
    print('    if ($docs_redirect_target != "") {')
    print('        return 301 $docs_redirect_target;')
    print('    }')
    print(f'    # sitemap에 없는 URL → fallback')
    print(f'    return 307 {fallback_host}$request_uri;')
    print('}')


def output_nextjs(redirect_map: dict, fallback_host: str):
    """Next.js redirects 배열 형식으로 출력합니다."""
    redirects = []
    for source, info in sorted(redirect_map.items()):
        redirects.append({
            'source': source,
            'destination': info['target'],
            'permanent': True,
        })
    # fallback: /docs/:path* → docs.querypie.com/docs/:path*
    redirects.append({
        'source': '/docs/:path*',
        'destination': f'{fallback_host}/:path*',
        'permanent': False,
    })
    print('// next.config.js의 redirects에 추가')
    print('async redirects() {')
    print('  return')
    print(json.dumps(redirects, ensure_ascii=False, indent=4))
    print('}')


def output_vercel(redirect_map: dict, fallback_host: str):
    """Vercel JSON redirects 형식으로 출력합니다."""
    redirects = []
    for source, info in sorted(redirect_map.items()):
        redirects.append({
            'source': source,
            'destination': info['target'],
            'statusCode': 301,
        })
    redirects.append({
        'source': '/docs/:path*',
        'destination': f'{fallback_host}/:path*',
        'statusCode': 307,
    })
    result = {'redirects': redirects}
    print(json.dumps(result, ensure_ascii=False, indent=2))


def main():
    parser = argparse.ArgumentParser(
        description='www.querypie.com/docs/* 리다이렉트 맵 생성',
    )
    parser.add_argument('--format', choices=['json', 'nginx', 'nextjs', 'vercel'],
                        default='json', help='출력 형식 (기본: json)')
    parser.add_argument('--output', '-o', type=str,
                        help='출력 파일 (미지정 시 stdout)')
    args = parser.parse_args()

    redirect_map = build_redirect_map(TARGETS)

    total = len(redirect_map)
    by_target = {}
    for info in redirect_map.values():
        src = info['source']
        by_target[src] = by_target.get(src, 0) + 1
    print(f'총 {total}개 리다이렉트 규칙 생성', file=sys.stderr)
    for name, count in by_target.items():
        print(f'  {name}: {count}건 (301)', file=sys.stderr)
    print(f'  fallback → {FALLBACK_HOST} (307)', file=sys.stderr)

    if args.output:
        sys.stdout = open(args.output, 'w', encoding='utf-8')

    formatters = {
        'json': output_json,
        'nginx': output_nginx,
        'nextjs': output_nextjs,
        'vercel': output_vercel,
    }
    formatters[args.format](redirect_map, FALLBACK_HOST)

    if args.output:
        sys.stdout.close()
        print(f'출력 저장: {args.output}', file=sys.stderr)


if __name__ == '__main__':
    main()
