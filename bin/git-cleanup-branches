#!/usr/bin/env python3.12
"""
Git Cleanup Branches

Scans git repositories under a workspace directory and identifies stale branches
that have been merged or closed via PR.
"""

from __future__ import annotations

import argparse
import subprocess
import sys
from datetime import datetime, timedelta
from pathlib import Path


def run_command(cmd: list[str], cwd: str | None = None) -> tuple[int, str, str]:
    """Run a command and return (returncode, stdout, stderr)."""
    try:
        result = subprocess.run(
            cmd,
            cwd=cwd,
            capture_output=True,
            text=True,
            timeout=30,
        )
        return result.returncode, result.stdout.strip(), result.stderr.strip()
    except subprocess.TimeoutExpired:
        return 1, "", "Command timed out"
    except Exception as e:
        return 1, "", str(e)


def check_prerequisites() -> bool:
    """Check if required tools are installed."""
    code, _, _ = run_command(["gh", "--version"])
    if code != 0:
        print("Error: gh CLI is not installed.")
        print("Install it from: https://cli.github.com/")
        return False

    code, _, _ = run_command(["gh", "auth", "status"])
    if code != 0:
        print("Error: gh CLI is not authenticated.")
        print("Run: gh auth login")
        return False

    return True


def find_git_repos(workspace: Path) -> list[Path]:
    """Find all git repositories under the workspace directory."""
    repos = []

    if not workspace.exists():
        print(f"Error: Workspace directory does not exist: {workspace}")
        return repos

    for item in workspace.iterdir():
        if item.is_dir() and (item / ".git").exists():
            repos.append(item)

    return sorted(repos)


def get_base_branch(repo_path: Path) -> str:
    """Determine the base branch for a repository."""
    repo_name = repo_path.name
    if repo_name == "querypie-mono":
        return "develop"
    return "main"


def get_local_branches(repo_path: Path) -> list[str]:
    """Get list of local branches excluding base branches."""
    code, stdout, _ = run_command(
        ["git", "branch", "--format=%(refname:short)"],
        cwd=str(repo_path),
    )
    if code != 0 or not stdout:
        return []

    base_branch = get_base_branch(repo_path)
    exclude = {"main", "master", "develop", base_branch}

    branches = []
    for line in stdout.split("\n"):
        branch = line.strip()
        if branch and branch not in exclude:
            branches.append(branch)

    return branches


def get_last_commit_date(repo_path: Path, branch: str) -> datetime | None:
    """Get the date of the last commit on a branch."""
    code, stdout, _ = run_command(
        ["git", "log", "-1", "--format=%ct", branch],
        cwd=str(repo_path),
    )
    if code != 0 or not stdout:
        return None

    try:
        timestamp = int(stdout.strip())
        return datetime.fromtimestamp(timestamp)
    except (ValueError, OSError):
        return None


def get_pr_status(repo_path: Path, branch: str) -> str | None:
    """Get PR status for a branch using gh CLI."""
    code, stdout, _ = run_command(
        [
            "gh", "pr", "list",
            "--head", branch,
            "--state", "all",
            "--json", "state",
            "--jq", ".[0].state",
        ],
        cwd=str(repo_path),
    )
    if code != 0 or not stdout:
        return None

    state = stdout.strip().upper()
    if state in ("MERGED", "CLOSED", "OPEN"):
        return state
    return None


def has_remote_branch(repo_path: Path, branch: str) -> bool:
    """Check if a remote tracking branch exists."""
    code, _, _ = run_command(
        ["git", "rev-parse", "--verify", f"origin/{branch}"],
        cwd=str(repo_path),
    )
    return code == 0


def fetch_repo(repo_path: Path) -> bool:
    """Fetch and prune remote tracking branches."""
    code, _, stderr = run_command(
        ["git", "fetch", "--prune"],
        cwd=str(repo_path),
    )
    if code != 0:
        print(f"    ! fetch failed: {stderr}")
        return False
    return True


def delete_branch(repo_path: Path, branch: str) -> bool:
    """Delete a local branch."""
    code, _, stderr = run_command(
        ["git", "branch", "-D", branch],
        cwd=str(repo_path),
    )
    if code != 0:
        print(f"    ! delete failed: {stderr}")
        return False
    return True


def main() -> int:
    parser = argparse.ArgumentParser(
        description="Scan workspace and cleanup stale branches in git repositories",
    )
    parser.add_argument(
        "--workspace",
        type=Path,
        default=Path.home() / "workspace",
        help="Workspace directory to scan (default: ~/workspace)",
    )
    parser.add_argument(
        "--days",
        type=int,
        default=14,
        help="Only check branches with commits within this many days (default: 14)",
    )
    parser.add_argument(
        "--delete",
        action="store_true",
        help="Actually delete stale branches (default: dry-run)",
    )
    args = parser.parse_args()

    if not check_prerequisites():
        return 1

    workspace = args.workspace.expanduser().resolve()
    cutoff_date = datetime.now() - timedelta(days=args.days)

    print(f"Workspace: {workspace}")
    print(f"Checking branches with commits in the last {args.days} days")
    print(f"Mode: {'DELETE' if args.delete else 'dry-run'}")
    print()

    repos = find_git_repos(workspace)
    if not repos:
        print("No git repositories found.")
        return 0

    total_repos = len(repos)
    all_stale: list[tuple[Path, str]] = []

    for idx, repo_path in enumerate(repos, 1):
        repo_name = repo_path.name
        base_branch = get_base_branch(repo_path)

        print(f"[{idx}/{total_repos}] {repo_name} (base: {base_branch})")

        # Fetch
        print("    fetching...", end=" ", flush=True)
        if fetch_repo(repo_path):
            print("done")
        else:
            print()
            continue

        branches = get_local_branches(repo_path)
        if not branches:
            print("    (no local branches)")
            print()
            continue

        has_output = False
        for branch in branches:
            # Check last commit date
            last_commit = get_last_commit_date(repo_path, branch)
            if last_commit is None:
                continue

            commit_date_str = last_commit.strftime("%Y-%m-%d")

            if last_commit < cutoff_date:
                # Skip old branches silently
                continue

            # Check PR status
            pr_status = get_pr_status(repo_path, branch)
            remote_exists = has_remote_branch(repo_path, branch)
            remote_str = "remote:exists" if remote_exists else "remote:deleted"

            # Determine status
            if pr_status in ("MERGED", "CLOSED"):
                status = "STALE"
                all_stale.append((repo_path, branch))
            elif pr_status == "OPEN":
                status = "keep (PR open)"
            elif pr_status is None:
                status = "keep (no PR)"
            else:
                status = "keep"

            # Build info string
            pr_str = f"PR:{pr_status}" if pr_status else "PR:none"
            info = f"{pr_str} | {commit_date_str} | {remote_str}"

            # Print result
            if status == "STALE":
                print(f"    {branch}")
                print(f"      {info} → STALE")
                has_output = True
            else:
                print(f"    {branch}")
                print(f"      {info} → {status}")
                has_output = True

        if not has_output:
            print("    (no recent branches)")

        print()

    # Summary
    print("=" * 50)
    if not all_stale:
        print("No stale branches found.")
        return 0

    repo_count = len(set(r for r, _ in all_stale))
    print(f"Found {len(all_stale)} stale branches in {repo_count} repositories")
    print()

    if not args.delete:
        print("Stale branches:")
        for repo_path, branch in all_stale:
            print(f"  {repo_path.name}: {branch}")
        print()
        print("Run with --delete to remove these branches.")
        return 0

    # Delete branches
    print("Deleting stale branches...")
    print()

    deleted = 0
    for repo_path, branch in all_stale:
        print(f"  {repo_path.name}: {branch}", end=" ", flush=True)
        if delete_branch(repo_path, branch):
            print("✓")
            deleted += 1
        else:
            print("✗")

    print()
    print(f"Deleted {deleted}/{len(all_stale)} branches.")

    return 0


if __name__ == "__main__":
    sys.exit(main())
