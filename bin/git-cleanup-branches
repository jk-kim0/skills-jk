#!/usr/bin/env python3.12
"""
Git Cleanup Branches

Scans git repositories under a workspace directory and identifies stale branches
that have been merged or closed via PR.
"""

from __future__ import annotations

import argparse
import subprocess
import sys
from datetime import datetime, timedelta
from pathlib import Path


def run_command(cmd: list[str], cwd: str | None = None) -> tuple[int, str, str]:
    """Run a command and return (returncode, stdout, stderr)."""
    try:
        result = subprocess.run(
            cmd,
            cwd=cwd,
            capture_output=True,
            text=True,
            timeout=30,
        )
        return result.returncode, result.stdout.strip(), result.stderr.strip()
    except subprocess.TimeoutExpired:
        return 1, "", "Command timed out"
    except Exception as e:
        return 1, "", str(e)


def check_prerequisites() -> bool:
    """Check if required tools are installed."""
    code, _, _ = run_command(["gh", "--version"])
    if code != 0:
        print("Error: gh CLI is not installed.")
        print("Install it from: https://cli.github.com/")
        return False

    code, _, _ = run_command(["gh", "auth", "status"])
    if code != 0:
        print("Error: gh CLI is not authenticated.")
        print("Run: gh auth login")
        return False

    return True


def find_git_repos(workspace: Path) -> list[Path]:
    """Find all git repositories under the workspace directory."""
    repos = []

    if not workspace.exists():
        print(f"Error: Workspace directory does not exist: {workspace}")
        return repos

    for item in workspace.iterdir():
        if item.is_dir() and (item / ".git").exists():
            repos.append(item)

    return sorted(repos)


def get_base_branch(repo_path: Path) -> str:
    """Determine the base branch for a repository."""
    repo_name = repo_path.name
    if repo_name == "querypie-mono":
        return "develop"
    return "main"


def get_local_branches(repo_path: Path) -> list[str]:
    """Get list of local branches excluding base branches."""
    code, stdout, _ = run_command(
        ["git", "branch", "--format=%(refname:short)"],
        cwd=str(repo_path),
    )
    if code != 0 or not stdout:
        return []

    base_branch = get_base_branch(repo_path)
    exclude = {"main", "master", "develop", base_branch}

    branches = []
    for line in stdout.split("\n"):
        branch = line.strip()
        if branch and branch not in exclude:
            branches.append(branch)

    return branches


def get_last_commit_date(repo_path: Path, branch: str) -> datetime | None:
    """Get the date of the last commit on a branch."""
    code, stdout, _ = run_command(
        ["git", "log", "-1", "--format=%ct", branch],
        cwd=str(repo_path),
    )
    if code != 0 or not stdout:
        return None

    try:
        timestamp = int(stdout.strip())
        return datetime.fromtimestamp(timestamp)
    except (ValueError, OSError):
        return None


def get_pr_status(repo_path: Path, branch: str) -> str | None:
    """Get PR status for a branch using gh CLI."""
    code, stdout, _ = run_command(
        [
            "gh", "pr", "list",
            "--head", branch,
            "--state", "all",
            "--json", "state",
            "--jq", ".[0].state",
        ],
        cwd=str(repo_path),
    )
    if code != 0 or not stdout:
        return None

    state = stdout.strip().upper()
    if state in ("MERGED", "CLOSED", "OPEN"):
        return state
    return None


def has_remote_branch(repo_path: Path, branch: str) -> bool:
    """Check if a remote tracking branch exists."""
    code, _, _ = run_command(
        ["git", "rev-parse", "--verify", f"origin/{branch}"],
        cwd=str(repo_path),
    )
    return code == 0


def get_current_branch(repo_path: Path) -> str | None:
    """Get the currently checked out branch."""
    code, stdout, _ = run_command(
        ["git", "branch", "--show-current"],
        cwd=str(repo_path),
    )
    if code != 0 or not stdout:
        return None
    return stdout.strip()


def fetch_repo(repo_path: Path) -> bool:
    """Fetch and prune remote tracking branches."""
    code, _, stderr = run_command(
        ["git", "fetch", "--prune"],
        cwd=str(repo_path),
    )
    if code != 0:
        print(f"    ! fetch failed: {stderr}")
        return False
    return True


def delete_branch(repo_path: Path, branch: str) -> bool:
    """Delete a local branch, switching to base branch first if necessary."""
    current = get_current_branch(repo_path)
    if current == branch:
        base_branch = get_base_branch(repo_path)
        code, _, stderr = run_command(
            ["git", "checkout", base_branch],
            cwd=str(repo_path),
        )
        if code != 0:
            print(f"    ! checkout {base_branch} failed: {stderr}")
            return False

    code, _, stderr = run_command(
        ["git", "branch", "-D", branch],
        cwd=str(repo_path),
    )
    if code != 0:
        print(f"    ! delete failed: {stderr}")
        return False
    return True


def main() -> int:
    parser = argparse.ArgumentParser(
        description="Scan workspace and cleanup stale branches in git repositories",
    )
    parser.add_argument(
        "dirs",
        nargs="*",
        help="Directory names under workspace to scan (default: all repos)",
    )
    parser.add_argument(
        "--workspace",
        type=Path,
        default=Path.home() / "workspace",
        help="Workspace directory to scan (default: ~/workspace)",
    )
    parser.add_argument(
        "--days",
        type=int,
        default=14,
        help="Only check branches with commits within this many days (default: 14)",
    )
    parser.add_argument(
        "--delete",
        action="store_true",
        help="Actually delete stale branches (default: dry-run)",
    )
    args = parser.parse_args()

    if not check_prerequisites():
        return 1

    workspace = args.workspace.expanduser().resolve()
    cutoff_date = datetime.now() - timedelta(days=args.days)

    print(f"Workspace: {workspace}")
    print(f"Checking branches with commits in the last {args.days} days")
    print(f"Mode: {'DELETE' if args.delete else 'dry-run'}")
    print()

    if args.dirs:
        repos = []
        for name in args.dirs:
            repo_path = workspace / name
            if not repo_path.is_dir():
                print(f"Warning: {repo_path} does not exist, skipping")
            elif not (repo_path / ".git").exists():
                print(f"Warning: {repo_path} is not a git repository, skipping")
            else:
                repos.append(repo_path)
        repos.sort()
    else:
        repos = find_git_repos(workspace)

    if not repos:
        print("No git repositories found.")
        return 0

    total_repos = len(repos)
    all_stale: list[tuple[Path, str]] = []

    for idx, repo_path in enumerate(repos, 1):
        repo_name = repo_path.name
        base_branch = get_base_branch(repo_path)

        print(f"[{idx}/{total_repos}] {repo_name} (base: {base_branch})")

        # Fetch
        print("  - fetching...", end=" ", flush=True)
        if fetch_repo(repo_path):
            print("done")
        else:
            print()
            continue

        branches = get_local_branches(repo_path)
        if not branches:
            print("  - no local branches to check")
            print()
            continue

        print(f"  - checking {len(branches)} branch(es)...")

        for branch in branches:
            # Print branch being checked
            print(f"    > {branch}: ", end="", flush=True)

            # Check last commit date
            last_commit = get_last_commit_date(repo_path, branch)
            if last_commit is None:
                print("skip (no commit info)")
                continue

            commit_date_str = last_commit.strftime("%Y-%m-%d")

            if last_commit < cutoff_date:
                print(f"skip (old: {commit_date_str})")
                continue

            # Check PR status
            print("checking PR...", end=" ", flush=True)
            pr_status = get_pr_status(repo_path, branch)
            remote_exists = has_remote_branch(repo_path, branch)

            # Build status parts
            pr_str = pr_status if pr_status else "none"
            remote_str = "remote" if remote_exists else "no-remote"

            # Determine and print result
            if pr_status in ("MERGED", "CLOSED"):
                all_stale.append((repo_path, branch))
                print(f"STALE [PR:{pr_str}, {commit_date_str}, {remote_str}]")
            elif pr_status == "OPEN":
                print(f"keep [PR:OPEN, {commit_date_str}, {remote_str}]")
            else:
                print(f"keep [no PR, {commit_date_str}, {remote_str}]")

        print()

    # Summary
    print("---")
    if not all_stale:
        print("Result: No stale branches found.")
        return 0

    repo_count = len(set(r for r, _ in all_stale))
    print(f"Result: {len(all_stale)} stale branch(es) in {repo_count} repo(s)")
    print()

    if not args.delete:
        print("Stale branches:")
        for repo_path, branch in all_stale:
            print(f"  - {repo_path.name}/{branch}")
        print()
        print("Run with --delete to remove these branches.")
        return 0

    # Delete branches
    print("Deleting stale branches...")

    deleted = 0
    for repo_path, branch in all_stale:
        print(f"  - {repo_path.name}/{branch}: ", end="", flush=True)
        if delete_branch(repo_path, branch):
            print("deleted")
            deleted += 1
        else:
            print("failed")

    print()
    print(f"Done: {deleted}/{len(all_stale)} deleted.")

    return 0


if __name__ == "__main__":
    sys.exit(main())
